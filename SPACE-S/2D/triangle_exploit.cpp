//Begin page main
float myState[12];
float enState[12];
#define myPos (&myState[0])
#define myVel (&myState[3])
#define myAtt (&myState[6])
#define myRot (&myState[9])
#define enPos (&enState[0])
#define enVel (&enState[3])
#define enAtt (&enState[6])
#define enRot (&enState[9])

int time;
#define ROUND_LENGTH 180

int spsNum;

float spsLoc[3][3]; 
float oldPos[3];
void init(){
    #define SPEEDCONST .38
    api.setPosGains(SPEEDCONST,0.1,7 * SPEEDCONST);
    spsNum = 0;
    memset(spsLoc, 0.0f, 36);
    spsLoc[0][0] = 1.5;
    spsLoc[0][1] = 1.5;
    spsLoc[1][0] = -2.933*1.0;
    spsLoc[1][1] = 1.450*1.0;
    spsLoc[2][0] = -3.5;
    spsLoc[2][1] = -3;
    api.getMyZRState(myState);
    
    if (myPos[1]>0) {
        for (int i=0; i<3; i++) {
            scale(spsLoc[i], -1);
        }
    }
}

void loop(){
	api.getMyZRState(myState);
    api.getOtherZRState(enState);
    time = game.getCurrentTime();
    
    if (dist(myPos, spsLoc[spsNum]) < 0.22 or (dist(oldPos,myPos)<.03 and dist(myPos, spsLoc[spsNum]) < 0.6)) {
        spsNum++;
        game.dropSPS();
    }
    memcpy(oldPos,myPos,12);
    api.setPositionTarget(spsLoc[spsNum]);
    DEBUG(("%f %f %f", spsLoc[spsNum][0], spsLoc[spsNum][1], spsLoc[spsNum][2]));
    if (ROUND_LENGTH - time < 2) {game.dropSPS();game.dropSPS();game.dropSPS();}
}

float dist(float* vec1, float* vec2) {
    float diff[3];
    mathVecSubtract(diff, vec1, vec2, 3);
    return mathVecMagnitude(diff,3);
}

void scale (float* vec, float scale) {
    for (int i=0; i<3; i++) {
        vec[i] *= scale;
        // a = a*b
        // a *= b
    }
}
//End page main
